<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Vector PDF & Image Cropper</title>
    <style>
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #e0e0e0;
            font-family: sans-serif;
        }
        #toolbar, #infoToolbar {
            position: fixed; top: 15px; z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            display: flex; gap: 10px; align-items: center; border: 1px solid #ccc;
        }
        #toolbar { left: 15px; }
        #infoToolbar { right: 15px; min-width: 100px; justify-content: center; }

        canvas { position: absolute; top: 0; left: 0; }
        #canvasImage { z-index: 1; }
        #canvasCrop  { z-index: 2; cursor: default; }

        button {
            padding: 6px 12px; cursor: pointer; border-radius: 4px;
            border: 1px solid #999; background: white; font-weight: bold;
        }
        #confirmBtn { background: #4CAF50; color: white; border: none; }
        #invertBtn.active { background: #263238; color: white; }
        .round-tool { background: #2196F3; color: white; border: none; font-size: 16px; }
        .label-mm { font-weight: bold; color: #333; font-size: 14px; }
    </style>
</head>
<body>

<div id="toolbar">
    <input type="file" id="fileInput" accept="image/*,.pdf">
    <button id="invertBtn">◐ Інверсія</button>
    <button id="cropBtn">Обрізати</button>

    <button class="round-tool align-btn" data-type="floor" style="display:none;">↓</button>
    <button class="round-tool align-btn" data-type="round" style="display:none;">≈</button>
    <button class="round-tool align-btn" data-type="ceil"  style="display:none;">↑</button>

    <button id="confirmBtn" style="display:none;">Підтвердити</button>
    <button id="cancelBtn" style="display:none;">Скасувати</button>
</div>

<div id="infoToolbar">
    <span class="label-mm" id="sizeDisplay">0 x 0 мм</span>
</div>

<canvas id="canvasImage"></canvas>
<canvas id="canvasCrop"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

    const canvasImg = document.getElementById("canvasImage"), ctxImg = canvasImg.getContext("2d");
    const canvasCrp = document.getElementById("canvasCrop"), ctxCrp = canvasCrp.getContext("2d");
    const fileInput = document.getElementById("fileInput"), invertBtn = document.getElementById("invertBtn");
    const cropBtn = document.getElementById("cropBtn"), confirmBtn = document.getElementById("confirmBtn");
    const cancelBtn = document.getElementById("cancelBtn"), sizeDisplay = document.getElementById("sizeDisplay");
    const alignBtns = document.querySelectorAll(".align-btn");

    let dpr = window.devicePixelRatio || 1;
    let currentImg = null, originalImg = null, pdfDoc = null, pdfPage = null;
    let pdfViewBox = null, currentCoords = null, currentScale = 1;
    let isInverted = false, cropMode = false, cropRect = null;

    let dragging = false, dragPart = null, dragOffset = {x:0, y:0};

    const sidePad = 40, topPad = 80;

    function getDPI() { return currentImg ? 96 : 72; }
    function getUnitsPerPx() {
        return currentCoords ? (currentImg ? 1/currentScale : pdfViewBox.w/currentCoords.w) : 1;
    }

    function updateSize() {
        let w = 0, h = 0;
        const dpi = getDPI(), uPx = getUnitsPerPx();
        if (cropMode && cropRect) { w = cropRect.w * uPx; h = cropRect.h * uPx; }
        else if (currentImg) { w = currentImg.width; h = currentImg.height; }
        else if (pdfViewBox) { w = pdfViewBox.w; h = pdfViewBox.h; }
        sizeDisplay.innerText = `${((w/dpi)*25.4).toFixed(1)} x ${((h/dpi)*25.4).toFixed(1)} мм`;
    }

    async function drawMain() {
        ctxImg.clearRect(0, 0, canvasImg.width/dpr, canvasImg.height/dpr);
        if (!currentImg && !pdfPage) return;

        let cw = currentImg ? currentImg.width : pdfViewBox.w;
        let ch = currentImg ? currentImg.height : pdfViewBox.h;
        let scale = Math.min((window.innerWidth - sidePad*2)/cw, (window.innerHeight - topPad - sidePad)/ch);
        currentScale = scale;

        let w = cw * scale, h = ch * scale;
        let x = (window.innerWidth - w)/2, y = topPad + (window.innerHeight - topPad - sidePad - h)/2;
        currentCoords = {x, y, w, h};

        ctxImg.save();
        if (currentImg) {
            ctxImg.drawImage(currentImg, x, y, w, h);
        } else {
            const vp = pdfPage.getViewport({ scale });
            await pdfPage.render({
                canvasContext: ctxImg, viewport: vp,
                transform: [1, 0, 0, 1, x - (pdfViewBox.x * scale), y - (pdfViewBox.y * scale)]
            }).promise;
        }

        if (isInverted) {
            ctxImg.globalCompositeOperation = "difference";
            ctxImg.fillStyle = "white";
            ctxImg.fillRect(x, y, w, h);
        }
        ctxImg.restore();

        ctxImg.strokeStyle = "red"; ctxImg.setLineDash([4, 4]);
        ctxImg.strokeRect(x, y, w, h);
        updateSize();
    }

    function drawCropFrame() {
        ctxCrp.clearRect(0, 0, canvasCrp.width/dpr, canvasCrp.height/dpr);
        if (!cropMode || !cropRect) return;

        ctxCrp.fillStyle = "rgba(0,0,0,0.4)";
        ctxCrp.fillRect(0, 0, canvasCrp.width/dpr, canvasCrp.height/dpr);
        ctxCrp.clearRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);

        ctxCrp.strokeStyle = "#00bfff"; ctxCrp.lineWidth = 2;
        ctxCrp.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);

        // Малюємо маркери
        ctxCrp.fillStyle = "white";
        const s = 8;
        [[0,0],[1,0],[0,1],[1,1]].forEach(p => {
            ctxCrp.fillRect(cropRect.x + p[0]*cropRect.w - s/2, cropRect.y + p[1]*cropRect.h - s/2, s, s);
            ctxCrp.strokeRect(cropRect.x + p[0]*cropRect.w - s/2, cropRect.y + p[1]*cropRect.h - s/2, s, s);
        });
        updateSize();
    }

    function getPart(mx, my) {
        if (!cropRect) return null;
        const s = 15;
        const {x, y, w, h} = cropRect;
        if (Math.abs(mx-x)<s && Math.abs(my-y)<s) return "tl";
        if (Math.abs(mx-(x+w))<s && Math.abs(my-y)<s) return "tr";
        if (Math.abs(mx-x)<s && Math.abs(my-(y+h))<s) return "bl";
        if (Math.abs(mx-(x+w))<s && Math.abs(my-(y+h))<s) return "br";
        if (Math.abs(my-y)<s && mx>x && mx<x+w) return "t";
        if (Math.abs(my-(y+h))<s && mx>x && mx<x+w) return "b";
        if (Math.abs(mx-x)<s && my>y && my<y+h) return "l";
        if (Math.abs(mx-(x+w))<s && my>y && my<y+h) return "r";
        if (mx>x && mx<x+w && my>y && my<y+h) return "center";
        return null;
    }

    canvasCrp.addEventListener("mousedown", e => {
        if (!cropMode) return;
        const part = getPart(e.offsetX, e.offsetY);
        if (!part) return;
        dragPart = part; dragging = true;
        dragOffset = { x: e.offsetX - cropRect.x, y: e.offsetY - cropRect.y };
    });

    window.addEventListener("mousemove", e => {
        const mx = e.offsetX, my = e.offsetY;
        if (cropMode && !dragging) {
            const p = getPart(mx, my);
            const cursors = { tl:"nwse-resize", br:"nwse-resize", tr:"nesw-resize", bl:"nesw-resize", t:"ns-resize", b:"ns-resize", l:"ew-resize", r:"ew-resize", center:"move" };
            canvasCrp.style.cursor = cursors[p] || "default";
        }
        if (!dragging) return;
        const min = 10;
        if (dragPart === "center") {
            cropRect.x = mx - dragOffset.x; cropRect.y = my - dragOffset.y;
        } else {
            if (dragPart.includes("t")) { let d = cropRect.y - my; if(cropRect.h+d>min){ cropRect.h+=d; cropRect.y=my; } }
            if (dragPart.includes("b")) cropRect.h = Math.max(min, my - cropRect.y);
            if (dragPart.includes("l")) { let d = cropRect.x - mx; if(cropRect.w+d>min){ cropRect.w+=d; cropRect.x=mx; } }
            if (dragPart.includes("r")) cropRect.w = Math.max(min, mx - cropRect.x);
        }
        drawCropFrame();
    });

    window.addEventListener("mouseup", () => { dragging = false; });

    invertBtn.addEventListener("click", () => {
        isInverted = !isInverted; invertBtn.classList.toggle("active", isInverted); drawMain();
    });

    cropBtn.addEventListener("click", () => {
        if (!currentCoords) return;
        cropMode = true; cropRect = { ...currentCoords };
        [confirmBtn, cancelBtn].forEach(b => b.style.display = "inline");
        alignBtns.forEach(b => b.style.display = "inline");
        drawCropFrame();
    });

    confirmBtn.addEventListener("click", () => {
        const uPx = getUnitsPerPx();
        if (currentImg) {
            const sw = cropRect.w * uPx, sh = cropRect.h * uPx;
            const temp = document.createElement("canvas");
            temp.width = sw; temp.height = sh;
            const tCtx = temp.getContext("2d");
            const sx = (cropRect.x - currentCoords.x) * uPx, sy = (cropRect.y - currentCoords.y) * uPx;
            tCtx.drawImage(originalImg, sx, sy, sw, sh, 0, 0, sw, sh);
            if (isInverted) { tCtx.globalCompositeOperation = "difference"; tCtx.fillStyle="white"; tCtx.fillRect(0,0,sw,sh); }
            const img = new Image(); img.src = temp.toDataURL();
            img.onload = () => { originalImg = img; currentImg = img; isInverted = false; invertBtn.classList.remove("active"); exit(); };
        } else {
            pdfViewBox.x += (cropRect.x - currentCoords.x) * uPx;
            pdfViewBox.y += (cropRect.y - currentCoords.y) * uPx;
            pdfViewBox.w = cropRect.w * uPx; pdfViewBox.h = cropRect.h * uPx;
            exit();
        }
    });

    function exit() {
        cropMode = false; [confirmBtn, cancelBtn].forEach(b => b.style.display = "none");
        alignBtns.forEach(b => b.style.display = "none");
        ctxCrp.clearRect(0,0,canvasCrp.width/dpr, canvasCrp.height/dpr);
        drawMain();
    }

    cancelBtn.addEventListener("click", exit);

    fileInput.addEventListener("change", e => {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        if (file.type === "application/pdf") {
            reader.onload = async (ev) => {
                pdfDoc = await pdfjsLib.getDocument({data: ev.target.result}).promise;
                pdfPage = await pdfDoc.getPage(1);
                const vp = pdfPage.getViewport({scale: 1});
                pdfViewBox = { x: 0, y: 0, w: vp.width, h: vp.height };
                currentImg = null; drawMain();
            };
            reader.readAsArrayBuffer(file);
        } else {
            const img = new Image();
            img.onload = () => { originalImg = img; currentImg = img; pdfPage = null; drawMain(); };
            img.src = URL.createObjectURL(file);
        }
    });

    function resize() {
        const w = window.innerWidth, h = window.innerHeight;
        [canvasImg, canvasCrp].forEach(c => {
            c.style.width = w+"px"; c.style.height = h+"px";
            c.width = w*dpr; c.height = h*dpr;
        });
        ctxImg.setTransform(dpr,0,0,dpr,0,0); ctxCrp.setTransform(dpr,0,0,dpr,0,0);
        drawMain(); if(cropMode) drawCropFrame();
    }
    window.addEventListener("resize", resize);
    resize();
</script>
</body>
</html>
